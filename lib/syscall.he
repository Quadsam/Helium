#define SYS_read 0
fn read(fd: int, buf: ptr, count: int) -> int
{
	return syscall(SYS_read, fd, buf, count);
}

#define SYS_write 1
fn write(fd: int, str: ptr, count: int) -> int
{
	return syscall(SYS_write, fd, str, count);
}

#define SYS_open 2
fn open(filename: ptr, flags: int, mode: int) -> int
{
	return syscall(SYS_open, filename, flags, mode);
}

#define SYS_close 3
fn close(fd: int) -> int
{
	return syscall(SYS_close, fd);
}

#define SYS_stat 4
fn stat(filename: ptr, statbuf: ptr) -> int
{
	return syscall(SYS_stat, filename, statbuf);
}

#define SYS_fstat 5
fn fstat(fd: int, statbuf: ptr) -> int
{
	return syscall(SYS_fstat, fd, statbuf);
}

#define SYS_lstat 6
fn lstat(filename: ptr, statbuf: ptr) -> int
{
	return syscall(SYS_lstat, filename, statbuf);
}

#define SYS_poll 7
fn poll(ufds: ptr, nfds: int, timeout: int) -> int
{
	return syscall(SYS_poll, ufds, nfds, timeout);
}

// Reposition read/write file offset
// whence: 0 = SET, 1 = CUR, 2 = END
#define SYS_lseek 8
fn lseek(fd: int, offset: int, whence: int) -> int
{
	return syscall(SYS_lseek, fd, offset, whence);
}

// Map memory (allocating heap space)
// For simple allocation: addr=0, fd=-1, offset=0
#define SYS_mmap 9
fn mmap(addr: ptr, len: int, prot: int, flags: int, fd: int, offset: int) -> ptr
{
	return syscall(9, addr, len, prot, flags, fd, offset);
}

// Set protection of memory mapping
#define SYS_mprotect 10
fn mprotect(addr: ptr, size: int, prot: int) -> int
{
	return syscall(SYS_mprotect, addr, size, prot);
}

// Unmap memory (freeing heap space)
#define SYS_munmap 11
fn munmap(addr: ptr, len: int) -> int
{
	return syscall(SYS_munmap, addr, len);
}

#define SYS_brk 12
fn brk(addr: ptr) -> int
{
	return syscall(SYS_brk, addr);
}

// Get process ID
#define SYS_getpid 39
fn getpid() -> int
{
	return syscall(SYS_getpid);
}
// Create a child process
#define SYS_fork 57
fn fork() -> int
{
	return syscall(SYS_fork);
}

// Execute a program
#define SYS_execve 59
fn execve(filename: ptr, argv: ptr, envp: ptr) -> int
{
	return syscall(SYS_execve, filename, argv, envp);
}

#define SYS_exit 60
fn exit(code: int) -> int
{
	syscall(SYS_exit, code);
	return 0;
}

// Wait for process termination
#define SYS_wait4 61
fn wait4(pid: int, status: ptr, options: int, rusage: ptr) -> int
{
	return syscall(SYS_wait4, pid, status, options, rusage);
}

// Delete a name and possibly the file it refers to
#define SYS_unlink 87
fn unlink(pathname: ptr) -> int
{
	return syscall(SYS_unlink, pathname);
}

// Rename a file
#define SYS_rename 82
fn rename(oldname: ptr, newname: ptr) -> int
{
	return syscall(SYS_rename, oldname, newname);
}

// Create a directory
#define SYS_mkdir 83
fn mkdir(pathname: ptr, mode: int) -> int
{
	return syscall(SYS_mkdir, pathname, mode);
}